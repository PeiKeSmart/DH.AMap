# DH.AMap 使用示例

## 项目简介

DH.AMap 是基于 DH 框架的高德地图 SDK，提供了高德地图 API 的反向代理功能，可以有效隐藏高德地图密钥，防止密钥泄露。

## 安装

### NuGet 安装

```bash
dotnet add package DH.AMap
```

或在 Visual Studio 的 NuGet 包管理器中搜索 `DH.AMap` 进行安装。

## 快速开始

### 1. 配置高德地图密钥

DH.AMap 使用 NewLife 配置系统，配置会自动保存到配置文件中。

**首次运行时**，系统会自动在项目根目录的 `Config` 文件夹下创建 `AMapSetting.config` 文件（XML 格式）。

**配置方式**：

#### 方式一：直接编辑配置文件（推荐）
在 `Config/AMapSetting.config` 文件中配置：

```xml
<?xml version="1.0" encoding="utf-8"?>
<AMapSetting>
  <!-- 必填：高德地图 Key -->
  <AMapKey>your-amap-key-here</AMapKey>
  
  <!-- 必填：Web 服务 API 私钥（用于数字签名） -->
  <AMapSecret>your-amap-secret-here</AMapSecret>
  
  <!-- 可选：是否启用数字签名验证，默认 true -->
  <EnableSignature>true</EnableSignature>
</AMapSetting>
```

**重要说明**：
- **AMapKey**：高德地图应用的 Key（必填）
- **AMapSecret**：高德地图应用的私钥（必填，用于 Web 服务 API 的数字签名）
- **EnableSignature**：是否启用数字签名验证，默认为 true（建议保持开启）

**如何获取 Key 和 Secret？**
1. 登录 [高德开放平台控制台](https://console.amap.com/)
2. 创建应用，选择 "Web 服务" 类型
3. 应用管理中查看 **Key** 和 **私钥（Secret）**

#### 方式二：代码中配置
```csharp
AMapSetting.Current.AMapKey = "your-amap-key-here";
AMapSetting.Current.AMapSecret = "your-amap-secret-here";
AMapSetting.Current.EnableSignature = true;
AMapSetting.Current.Save();
```

### 2. 注册服务

DH.AMap 实现了 `IPekStartup` 接口，框架会自动注册相关服务和路由，无需手动配置。

### 3. 使用代理接口

DH.AMap 提供了以下代理端点：

#### 3.1 地图样式接口

```javascript
// 原始接口：https://webapi.amap.com/v4/map/styles?key=your-key&...
// 代理接口：/_AMapService/v4/map/styles（自动添加 jscode 参数）

fetch('/_AMapService/v4/map/styles')
  .then(response => response.json())
  .then(data => console.log(data));
```

#### 3.2 矢量地图接口

```javascript
// 原始接口：https://fmap01.amap.com/v3/vectormap?key=your-key&...
// 代理接口：/_AMapService/v3/vectormap（自动添加 jscode 参数）

fetch('/_AMapService/v3/vectormap')
  .then(response => response.json())
  .then(data => console.log(data));
```

#### 3.3 其他 REST API 接口

```javascript
// 原始接口：https://restapi.amap.com/v3/geocode/geo?key=your-key&address=...
// 代理接口：/_AMapService/v3/geocode/geo?address=...（自动添加 jscode 参数）

// 地理编码示例 - 无需传递 key 或 jscode 参数
fetch('/_AMapService/v3/geocode/geo?address=北京市朝阳区阜通东大街6号&city=010')
  .then(response => response.json())
  .then(data => console.log(data));
```

## 完整示例

### 示例 1：在 HTML 页面中使用

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>高德地图示例</title>
    <style>
        #map {
            width: 100%;
            height: 600px;
        }
    </style>
    <script src="/_AMapService/maps?v=2.0"></script>
</head>
<body>
    <div id="map"></div>
    <script>
        // 创建地图实例
        var map = new AMap.Map('map', {
            zoom: 11,
            center: [116.397428, 39.90923],
            viewMode: '3D'
        });

        // 使用代理接口进行地理编码
        fetch('/_AMapService/v3/geocode/geo?address=北京市朝阳区阜通东大街6号')
            .then(response => response.json())
            .then(data => {
                console.log('地理编码结果：', data);
                if (data.status === '1' && data.geocodes.length > 0) {
                    var location = data.geocodes[0].location.split(',');
                    map.setCenter([parseFloat(location[0]), parseFloat(location[1])]);
                    
                    // 添加标记
                    var marker = new AMap.Marker({
                        position: [parseFloat(location[0]), parseFloat(location[1])],
                        title: '阜通东大街6号'
                    });
                    map.add(marker);
                }
            });
    </script>
</body>
</html>
```

### 示例 2：在 Vue.js 中使用

```vue
<template>
  <div>
    <div id="map" style="width: 100%; height: 600px;"></div>
    <div>
      <input v-model="address" placeholder="输入地址" />
      <button @click="searchAddress">搜索</button>
    </div>
  </div>
</template>

<script>
import AMapLoader from '@amap/amap-jsapi-loader';

export default {
  name: 'AMapDemo',
  data() {
    return {
      map: null,
      address: ''
    }
  },
  mounted() {
    this.initMap();
  },
  methods: {
    async initMap() {
      AMapLoader.load({
        key: "any-string",  // 使用代理时，可以填写任意值，但建议直接通过 script 标签引入
        version: "2.0",
        plugins: ['AMap.Geocoder']
      }).then((AMap) => {
        this.map = new AMap.Map('map', {
          zoom: 11,
          center: [116.397428, 39.90923],
          viewMode: '3D'
        });
      }).catch(e => {
        console.error(e);
      });
    },
    async searchAddress() {
      try {
        const response = await fetch(`/_AMapService/v3/geocode/geo?address=${encodeURIComponent(this.address)}`);
        const data = await response.json();
        
        if (data.status === '1' && data.geocodes.length > 0) {
          const location = data.geocodes[0].location.split(',');
          this.map.setCenter([parseFloat(location[0]), parseFloat(location[1])]);
          
          // 添加标记
          const marker = new AMap.Marker({
            position: [parseFloat(location[0]), parseFloat(location[1])],
            title: this.address
          });
          this.map.add(marker);
        }
      } catch (error) {
        console.error('搜索失败：', error);
      }
    }
  }
}
</script>
```

### 示例 3：在 React 中使用

```jsx
import React, { useEffect, useRef, useState } from 'react';
import AMapLoader from '@amap/amap-jsapi-loader';

function AMapDemo() {
  const mapRef = useRef(null);
  const [map, setMap] = useState(null);
  const [address, setAddress] = useState('');

  useEffect(() => {
    AMapLoader.load({
      key: "any-string",  // 使用代理时，可以填写任意值，但建议直接通过 script 标签引入
      version: "2.0",
      plugins: ['AMap.Geocoder']
    }).then((AMap) => {
      const mapInstance = new AMap.Map(mapRef.current, {
        zoom: 11,
        center: [116.397428, 39.90923],
        viewMode: '3D'
      });
      setMap(mapInstance);
    }).catch(e => {
      console.error(e);
    });
  }, []);

  const searchAddress = async () => {
    try {
      const response = await fetch(`/_AMapService/v3/geocode/geo?address=${encodeURIComponent(address)}`);
      const data = await response.json();
      
      if (data.status === '1' && data.geocodes.length > 0) {
        const location = data.geocodes[0].location.split(',');
        map.setCenter([parseFloat(location[0]), parseFloat(location[1])]);
        
        const marker = new AMap.Marker({
          position: [parseFloat(location[0]), parseFloat(location[1])],
          title: address
        });
        map.add(marker);
      }
    } catch (error) {
      console.error('搜索失败：', error);
    }
  };

  return (
    <div>
      <div ref={mapRef} style={{ width: '100%', height: '600px' }} />
      <div>
        <input 
          value={address} 
          onChange={(e) => setAddress(e.target.value)} 
          placeholder="输入地址" 
        />
        <button onClick={searchAddress}>搜索</button>
      </div>
    </div>
  );
}

export default AMapDemo;
```

### 示例 4：后端 API 调用

```csharp
using Microsoft.AspNetCore.Mvc;

namespace YourNamespace.Controllers;

[ApiController]
[Route("api/[controller]")]
public class LocationController : ControllerBase
{
    private readonly IHttpClientFactory _httpClientFactory;

    public LocationController(IHttpClientFactory httpClientFactory)
    {
        _httpClientFactory = httpClientFactory;
    }

    [HttpGet("geocode")]
    public async Task<IActionResult> GetGeocode([FromQuery] string address)
    {
        var client = _httpClientFactory.CreateClient();
        
        // 使用内部代理接口，无需暴露密钥
        var response = await client.GetAsync(
            $"http://localhost:5000/_AMapService/v3/geocode/geo?address={Uri.EscapeDataString(address)}"
        );
        
        if (response.IsSuccessStatusCode)
        {
            var content = await response.Content.ReadAsStringAsync();
            return Content(content, "application/json");
        }
        
        return StatusCode((int)response.StatusCode);
    }

    [HttpGet("regeo")]
    public async Task<IActionResult> GetReGeocode([FromQuery] string location)
    {
        var client = _httpClientFactory.CreateClient();
        
        // 逆地理编码
        var response = await client.GetAsync(
            $"http://localhost:5000/_AMapService/v3/geocode/regeo?location={location}"
        );
        
        if (response.IsSuccessStatusCode)
        {
            var content = await response.Content.ReadAsStringAsync();
            return Content(content, "application/json");
        }
        
        return StatusCode((int)response.StatusCode);
    }
}
```

## 支持的接口

所有高德地图 REST API 都可以通过代理访问，只需将原始 URL 的域名部分替换为 `/_AMapService/` 即可：

- **原始地址**：`https://restapi.amap.com/v3/geocode/geo?...`
- **代理地址**：`/_AMapService/v3/geocode/geo?...`

### 常用 API 示例

| API 名称 | 原始地址 | 代理地址 |
|---------|---------|---------|
| 地理编码 | `https://restapi.amap.com/v3/geocode/geo` | `/_AMapService/v3/geocode/geo` |
| 逆地理编码 | `https://restapi.amap.com/v3/geocode/regeo` | `/_AMapService/v3/geocode/regeo` |
| 路径规划 | `https://restapi.amap.com/v3/direction/driving` | `/_AMapService/v3/direction/driving` |
| 输入提示 | `https://restapi.amap.com/v3/assistant/inputtips` | `/_AMapService/v3/assistant/inputtips` |
| POI 搜索 | `https://restapi.amap.com/v3/place/text` | `/_AMapService/v3/place/text` |
| IP 定位 | `https://restapi.amap.com/v3/ip` | `/_AMapService/v3/ip` |
| 天气查询 | `https://restapi.amap.com/v3/weather/weatherInfo` | `/_AMapService/v3/weather/weatherInfo` |

## 工作原理

DH.AMap 通过反向代理的方式工作，并支持高德地图最新的数字签名验证：

1. 前端调用代理接口（如 `/_AMapService/v3/geocode/geo?address=xxx`）
2. DH.AMap 拦截请求
3. 自动添加配置的 **Key**（添加 `key` 参数）
4. 如果启用了数字签名，计算签名并添加 **sig** 参数
   - 签名算法：`MD5(请求路径 + Secret)`
   - 例如：`MD5("/v3/geocode/geo?address=北京&key=xxx" + "your-secret")`
5. 转发请求到高德地图官方 API
6. 返回结果给前端

**重要说明**：
- **JavaScript API 加载**：使用 `/_AMapService/maps?v=2.0` 加载，自动添加 key，不需要签名
- **Web 服务 API**：前端调用时**无需传递任何密钥参数**，代理会自动添加 `key` 和 `sig` 参数

**数字签名验证的好处**：
- ✅ 防止 API 被盗用：即使 Key 泄露，没有 Secret 也无法正常调用
- ✅ 增强安全性：符合高德地图最新的安全规范
- ✅ 可选启用：通过 `EnableSignature` 配置控制是否启用签名

**代理方案的好处**：
- ✅ 前端代码中无需包含 Key 和 Secret
- ✅ 防止密钥泄露和被盗用
- ✅ 统一管理 API 密钥
- ✅ 便于密钥的更换和维护

## 注意事项

1. **密钥安全**：确保 `Config/AMapSetting.config` 配置文件不要提交到公开的代码仓库
2. **Key 和 Secret 区分**：
   - **AMapKey**：应用的 Key，用于标识应用
   - **AMapSecret**：应用的私钥，用于计算数字签名，**不能泄露**
3. **服务类型**：在高德控制台创建应用时，请选择 "Web 服务" 类型
4. **数字签名**：建议保持 `EnableSignature=true`，增强安全性
5. **跨域问题**：如果前端和后端部署在不同域名，需要配置 CORS
6. **性能优化**：代理会增加一定的网络延迟，建议在同一内网部署
7. **API 限制**：仍然受到高德地图 API 的配额和频率限制

## 高级配置

### Docker 部署

在 Docker 容器中部署时，建议将配置文件通过 Volume 挂载，避免将密钥打包到镜像中：

```dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:8.0
WORKDIR /app
COPY . .
# 配置文件目录挂载为 Volume
VOLUME /app/Config
ENTRYPOINT ["dotnet", "YourApp.dll"]
```

启动容器时挂载配置文件：

```bash
# 将宿主机的配置目录挂载到容器
docker run -d \
  -v /path/to/config:/app/Config \
  -p 5000:80 \
  your-app-image
```

### 环境变量（可选）

如果需要通过环境变量覆盖配置，可以在代码中添加环境变量读取逻辑：

```csharp
// 优先使用环境变量
var amapSecret = Environment.GetEnvironmentVariable("AMAP_SECRET");
if (!String.IsNullOrEmpty(amapSecret))
{
    AMapSetting.Current.AMapSecret = amapSecret;
}
```

## 测试项目

项目中提供了完整的测试项目 `Test.AMapWeb`，用于验证代理方案的实际使用效果。

### 测试项目功能

测试项目提供了以下功能页面：

1. **首页**：项目介绍和配置说明
2. **JavaScript API 测试**：测试地图 JS API 的加载和基础功能
3. **地理编码测试**：测试地址转坐标功能
4. **逆地理编码测试**：测试坐标转地址功能

### 运行测试项目

```bash
# 进入测试项目目录
cd Test.AMapWeb

# 配置高德地图密钥（首次运行后会生成配置文件）
# 编辑 Config/AMapSetting.config 文件

# 运行项目
dotnet run

# 访问测试页面
# http://localhost:5000/
```

### 测试验证要点

测试项目可以帮助您验证以下内容：

✅ **密钥隐藏效果**
- 查看浏览器页面源码，确认看不到高德地图密钥
- 打开浏览器开发者工具，查看网络请求，确认请求中不包含真实密钥
- 所有密钥在服务器端添加，前端完全感知不到

✅ **JavaScript API 加载**
- 通过代理端点 `/_AMapService/maps?v=2.0` 成功加载地图
- 地图正常显示，可以进行缩放、拖拽等交互操作
- 可以添加标记点等地图元素

✅ **REST API 调用**
- 地理编码接口（地址→坐标）正常工作
- 逆地理编码接口（坐标→地址）正常工作
- 返回的数据格式与官方 API 一致

✅ **前后端集成**
- ASP.NET Core MVC 项目中正常使用
- 页面加载速度正常，无明显延迟
- 错误处理机制有效

详细的测试项目说明请参考：[Test.AMapWeb/Readme.md](../Test.AMapWeb/Readme.md)

## 技术支持

- 公司：湖北登灏科技有限公司
- 网站：https://www.haocoding.com/
- 源码：https://github.com/PeiKeSmart/Pek.AspNetCore

## 许可证

MIT License

Copyright ©2020-2025 湖北登灏科技有限公司
